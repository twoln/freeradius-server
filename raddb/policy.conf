# -*- text -*-
##
## policy.conf	-- FreeRADIUS server configuration file.
##
##	http://www.freeradius.org/
##	$Id$
##

#
#  Policies are virtual modules, similar to those defined in the
#  "instantate" section of radiusd.conf.
#
#  Defining a policy here means that it can be referenced in multiple
#  places as a *name*, rather than as a series of conditions to match,
#  and actions to take.
#
#  Policies are something like subroutines in a normal language, but
#  they cannot be called recursively.  They MUST be defined in order.
#  If policy A calls policy B, then B MUST be defined before A.
#
policy {
	#
	#	Forbid all EAP types.
	#
	forbid_eap {
		if (EAP-Message) {
			reject
		}
	}

	#
	#	Forbid all non-EAP types outside of an EAP tunnel.
	#
	permit_only_eap {
		if (!EAP-Message) {
			#  We MAY be inside of a TTLS tunnel.
			#  PEAP and EAP-FAST require EAP inside of
			#  the tunnel, so this check is OK.
			#  If so, then there MUST be an outer EAP message.
			if (!"%{outer.request:EAP-Message}") {
				reject
			}
		}
	}

	#
	#	Forbid all attempts to login via realms.
	#
	deny_realms {
		if (User-Name =~ /@|\\/) {
			reject
		}
	}

	#
	#	If you want the server to pretend that it is dead,
	#	then use the "do_not_respond" policy.
	#
	do_not_respond {
		update control {
			Response-Packet-Type := Do-Not-Respond
		}

		handled
	}


	#	The cui policies belong to the cui module.
	# 	See doc/cui_howto.txt for more information.
	#	cui_authorize adds the NULL CUI value to Access-Request
	#	thus making it a Chargeable-User-Identity request
	#
	cui_pre-proxy {
		update proxy-request {
                                Chargeable-User-Identity = '\\000'
                }
	}

	#	cui_postauth reacts to the Chargeable-User-Identity request
	#	by adding the md5 hash created from a configurable local
	#	salt (cui_hash_key) and the (inner) User-Name value
	#
	cui_postauth {
                if ( FreeRadius-Proxied-To == "127.0.0.1" ) {
	#
	#	when *returning* the CUI, add the CUI value to Access-Accept
	#	in inner auth, but only under the condition, that the CUI
	#	was set	in the request
	#
                                if ( outer.request:Chargeable-User-Identity ) {
                                        update outer.reply {
                                                Chargeable-User-Identity := "%{md5:%{config:cui_hash_key}%{request:User-Name}}"
                                        }
                                }
                }
                else {
	#
	#	when *returning* the CUI, add the CUI value to Access-Accept
	#	but only under the condition, that the CUI was set in 
	#	the request AND that the CUI was not already set in the inner
	#	tunnel
	#
                                if ( !("%{control:Proxy-To-Realm}") && (Chargeable-User-Identity) && !(reply:Chargeable-User-Identity) ) {
                                        update reply {
                                                Chargeable-User-Identity = "%{md5:%{config:cui_hash_key}%{request:User-Name}}"
                                        }
                                }
                }
        }

	#	cui_updatedb updates the temporary database adding 
	#	the record containing the received CUI value to be later
	#	used in accounting
	#
	cui_updatedb {
                if ( "%{reply:Chargeable-User-Identity}" ) {
                        cui
                }
        }

	#	cui_accounting reads the record form the temporary database,
	#	selects the corresponfing CUI value, as set cui_updatedb
	#	and adds the CUI attribute to the accounting request
	cui_accounting {
		if ("%{cui: SELECT cui FROM cui WHERE clientipaddress = '%{Client-IP-Address}' AND callingstationid = '%{Calling-Station-Id}' AND username = '%{User-Name}'}") {
                	update request {
                        	Chargeable-User-Identity = "%{cui: SELECT cui FROM cui WHERE clientipaddress = '%{Client-IP-Address}' AND callingstationid = '%{Calling-Station-Id}' AND username = '%{User-Name}'}"
                	}
			cui
        	}
	}
}
